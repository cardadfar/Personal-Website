{
  "key": {
    "t": "title",
    "s": "subtitle",
    "i": "img",
    "d": "img description",
    "p": "text"
  },

  "t_0": "Sketcher.",
  "w_0": [{"music-icon.png": ["https://www.youtube.com/watch?v=9aJVr5tTTWk", "Peace Sign by Kenshi Yonezu"]}, 
          {"software-icon.png": "After Effects CC • Processing"},
          {"code-icon.png": "Java • C++ • After Effects SDK • OpenGL"},
          {"time-icon.png": "3 Weeks"}],
  "p_1": "Sketcher is a real-time polygon rendering environment in After Effects written in C++ that links OpenGL with the After Effects SDK to render a sketch overlay on footage. It breaks down footage into its primitive 'sketch' form that remains as an editable layer in After Effects",
  "s_2": "Initial Processing Development",
  "p_3": "Within the first 2 days, I wrote a script in Processing to open an image and draw arcs on a separate canvas that would replicate the shape of the original image and export the separate canvas as an image. I created two separate drawing algorithms to achieve this.",
  "p_4": "The first, Point Forward, picks a pixel location that satisfies color input (if we are looking to draw over black pixels, then the pixel it chooses should be black), and then independently picks another pixel location that satisfies the same color input. If these two locations are close enough to each other, then they will be connected by an arc. If not, then a new pixel location is found until both the color input and distance parameters are satisfied. This process is repeated until 4 points are chosen and are connected by a bezier curve.",
  "p_5": "The second, Path Forward, behaves similarly except when finding points. After finding the first point in a curve, Path forward scans for points within a certain radius to connect with the first point. This reduces the time spent looking for points that satisfy the distance parameter.",
  "p_6": "The following parameters add to the sketcher's flexibility:",
  "l_1": "pts: number of points to search for.",
  "l_2": "dst: how far points are allowed to be.",
  "l_3": "Rand/Grid: choosing points at random vs dividing the canvas into pts/4 pieces and selecting points from each piece",
  "l_4": "Point List: saving location of color-satisfying pixel locations into an array for easy access. Rand/Grid selection will choose a point from this array rather than from the entire image.",
  "p_7": "Using these parameters, I was able to run some tests on the effects of the parameters on the output.",
  "i_8": "sketcher/flower-compilation.png",
  "d_9": "Testing the effects of the parameters on the output",
  "p_10": "Using After Effects, I added an edge-detection filter to the Black Clover ED & exported an image sequence. I modified the Processing script to handle batch exports before running the image sequence through the script. Compiling the exported images into a video, I was able to use the Processing script as an effect for the footage.",
  "i_11": "sketcher/clover-ed-processing.gif",
  "d_12": "Processing export of the Black Clover ED Chorus",
  "p_13": "One of the initial issues I noticed was that the curves would go through hollow areas of the image. This would lead to clouding up the image and making it harder to recognize.",
  "i_14": "sketcher/clover-ed-processing-error.png",
  "d_15": "Drawing curves across empty areas",
  "p_16": "The reason was that the script could choose two points that satisfy the color input and distance parameters, whereas the line that connects them could cross over an area that does not satisfy the color input. This is a frequent issue that I address later on.",
  "s_17": "After Effects Plug-in Development",
  "p_18": "Using what I had in Processing as a template, I wanted to make a similar version in After Effects that could be applied to layers as an effect. As it stood now, it was not very user friendly to export an image sequence, run it through Processing, then compile it back into After Effects. I wanted to keep everything inside After Effects so that it would be easier to pair this sketching algorithm with other effects in After Effects.",
  "p_19": "Adding a total of 3 weeks time, I got acquainted with the After Effects SDK long enough to be able to read from and write to the pixel data stored in After Effects' render buffer. Just like in the original Processing script, I could search for pixel locations and read their color values to verify if their color was in range of the input color. Unfortunately, c++, what the After Effects SDK is written in, does not come with a built-in graphics rendering library. My initial thought was to use Processing, but that was written in Java. Processing's c++ counterpart, OpenFrameworks, was my next stop, except it was used to render in a separate window and not onto After Effect's pixel buffer.",
  "p_20": "After Effects recommends using OpenGL for rendering graphics, as it comes with the ability to copy pixels from OpenGL's main framebuffer to After Effect's pixel buffer. Adobe even provides a library for specific AE SDK OpenGL commands to use, except these commands cause issues for many developers. GLator, as the library is called, operates on an older version of OpenGL that requires a lot of weird and extraneous library files to work, making it a hassle to set up. Instead, I went about creating my own lightweight version of GLator that instantiates a context of OpenGL within the After Effects SDK file.",
  "p_21": "The plug-in's algorithm is broken down into the following manner:",
  "l_22": "Checkout the pixel data as 'read' format.",
  "l_23": "Traverse the pixels, finding all pixels that are within range of the color input, and store their location in an array.",
  "l_24": "Checkin the pixel data.",
  "l_25": "Instantiate a Glew offscreen context.",
  "l_26": "Create a new temporary layer to render graphics on.",
  "l_27": "Select n points from the array of pixel locations that satisfy distance & straightness parameters.",
  "l_28": "Create and bind a framebuffer with a color-attachment texture buffer.",
  "l_29": "Create and bind an array buffer with a vertex array, making sure to upload the n points to the array buffer.",
  "l_30": "Create and assign vertex & frame shaders to the vertex array.",
  "l_31": "Create a shader program and set it as the current program.",
  "l_32": "Clear the color & depth buffers from the program &, by iterating over the size of the points array, draw the connected points.",
  "l_33": "Read the pixels into the newly created layer.",
  "l_34": "Destroy all OpenGL contexts and buffers.",
  "l_35": "Copy the layer's pixels into the output buffer & destroy the temporary layer.",
  "p_36": "It is important to destroy all created layers, contexts, & buffers before the program terminated. Failure to do so may cause memory leaks that will lead to the plug-in behaving in an unpredictable manner.",
  "p_37": "For greater flexibility, I added the following parameters into the After Effects Effects Panel:",
  "l_38": "Segments: number of points to draw.",
  "l_39": "Length: number of points per consecutive line.",
  "l_40": "Range: distance consecutive points of the same line can be from each other.",
  "l_41": "Straightness: length in degrees each angle of a line can make.",
  "l_42": "Drawing Mode: renders points, lines, or fills.",
  "l_43": "Line Color: color of the output",
  "l_44": "Color Detector: input color",
  "l_45": "Detector Range: range of acceptable input color",
  "l_46": "Spread: [debug-feature] how far apart lines would be.",
  "l_47": "Grid Selection: [debug-feature] selecting points in grid manner rather than at random.",
  "l_48": "Gap Selection: allowing lines to cross over gaps",
  "l_49": "Random Seed: random seed.",
  "l_50": "Subject Layer: layer to apply the effect on.",

}
