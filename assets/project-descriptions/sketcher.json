{
  "key": {
    "t": "title",
    "s": "subtitle",
    "i": "img",
    "d": "img description",
    "p": "text"
  },

  "t_0": "Sketcher.",
  "w_0": [{"music-icon.png": ["https://www.youtube.com/watch?v=9v2Dthlaesw", "Aoi Honoo by Itowokashi"]}, 
          {"software-icon.png": "After Effects CC • Processing"},
          {"code-icon.png": "Java • C++ • After Effects SDK • OpenGL"},
          {"time-icon.png": "3 Weeks"}],
  "p_1": "Sketcher is a real-time polygon rendering environment in After Effects written in C++ that links OpenGL with the After Effects SDK to render a sketch overlay on footage. It breaks down footage into its primitive 'sketch' form that remains as an editable layer in After Effects",
  "a_1": "https://github.com/cardadfar/Sketcher",
  "s_1": "Animation Comparisons.",
  "v_1": "https://player.vimeo.com/video/283946985",
  "d_1": "[Left: Solo Sketcher] • [Right: Original w/ Sketcher overlay]",
  "s_2": "Initial Processing Development.",
  "p_3": "Within the first 2 days, I wrote a script in Processing to open an image and draw arcs on a separate canvas that would replicate the shape of the original image and export the separate canvas as an image. I created two separate drawing algorithms to achieve this.",
  "p_4": "The first, Point Forward, picks a pixel location that satisfies color input (if we are looking to draw over black pixels, then the pixel it chooses should be black), and then independently picks another pixel location that satisfies the same color input. If these two locations are close enough to each other, then they will be connected by an arc. If not, then a new pixel location is found until both the color input and distance parameters are satisfied. This process is repeated until 4 points are chosen and are connected by a bezier curve.",
  "p_5": "The second, Path Forward, behaves similarly except when finding points. After finding the first point in a curve, Path forward scans for points within a certain radius to connect with the first point. This reduces the time spent looking for points that satisfy the distance parameter.",
  "p_6": "The following parameters add to the sketcher's flexibility:",
  "l_1": "pts: number of points to search for.",
  "l_2": "dst: how far points are allowed to be.",
  "l_3": "Rand/Grid: choosing points at random vs dividing the canvas into pts/4 pieces and selecting points from each piece",
  "l_4": "Point List: saving location of color-satisfying pixel locations into an array for easy access. Rand/Grid selection will choose a point from this array rather than from the entire image.",
  "p_7": "Using these parameters, I was able to run some tests on the effects of the parameters on the output.",
  "i_8": "sketcher/flower-compilation.png",
  "d_9": "Testing the effects of the parameters on the output",
  "p_10": "Using After Effects, I added an edge-detection filter to the Black Clover ED & exported an image sequence. I modified the Processing script to handle batch exports before running the image sequence through the script. Compiling the exported images into a video, I was able to use the Processing script as an effect for the footage.",
  "i_11": "sketcher/clover-ed-processing.gif",
  "d_12": "Processing export of the Black Clover ED Chorus",
  "p_13": "One of the initial issues I noticed was that the curves would go through hollow areas of the image. This would lead to clouding up the image and making it harder to recognize.",
  "i_14": "sketcher/clover-ed-processing-error.png",
  "d_15": "Drawing curves across empty areas",
  "p_16": "The reason was that the script could choose two points that satisfy the color input and distance parameters, whereas the line that connects them could cross over an area that does not satisfy the color input. This is a frequent issue that I address later on.",
  "s_17": "After Effects Plug-in Development.",
  "p_18": "Using what I had in Processing as a template, I wanted to make a similar version in After Effects that could be applied to layers as an effect. As it stood now, it was not very user friendly to export an image sequence, run it through Processing, then compile it back into After Effects. I wanted to keep everything inside After Effects so that it would be easier to pair this sketching algorithm with other effects in After Effects.",
  "p_19": "Adding a total of 3 weeks time, I got acquainted with the After Effects SDK long enough to be able to read from and write to the pixel data stored in After Effects' render buffer. Just like in the original Processing script, I could search for pixel locations and read their color values to verify if their color was in range of the input color. Unfortunately, c++, what the After Effects SDK is written in, does not come with a built-in graphics rendering library. My initial thought was to use Processing, but that was written in Java. Processing's c++ counterpart, OpenFrameworks, was my next stop, except it was used to render in a separate window and not onto After Effect's pixel buffer.",
  "p_20": "After Effects recommends using OpenGL for rendering graphics, as it comes with the ability to copy pixels from OpenGL's main framebuffer to After Effect's pixel buffer. Adobe even provides a library for specific AE SDK OpenGL commands to use, except these commands cause issues for many developers. GLator, as the library is called, operates on an older version of OpenGL that requires a lot of weird and extraneous library files to work, making it a hassle to set up. Instead, I went about creating my own lightweight version of GLator that instantiates a context of OpenGL within the After Effects SDK file.",
  "p_21": "The plug-in's algorithm is broken down into the following manner:",
  "l_22": "Checkout the pixel data as 'read' format.",
  "l_23": "Traverse the pixels, finding all pixels that are within range of the color input, and store their location in an array.",
  "l_24": "Checkin the pixel data.",
  "l_25": "Instantiate a Glew offscreen context.",
  "l_26": "Create a new temporary layer to render graphics on.",
  "l_27": "Select n points from the array of pixel locations that satisfy distance & straightness parameters.",
  "l_28": "Create and bind a framebuffer with a color-attachment texture buffer.",
  "l_29": "Create and bind an array buffer with a vertex array, making sure to upload the n points to the array buffer.",
  "l_30": "Create and assign vertex & frame shaders to the vertex array.",
  "l_31": "Create a shader program and set it as the current program.",
  "l_32": "Clear the color & depth buffers from the program &, by iterating over the size of the points array, draw the connected points.",
  "l_33": "Read the pixels into the newly created layer.",
  "l_34": "Destroy all OpenGL contexts and buffers.",
  "l_35": "Copy the layer's pixels into the output buffer & destroy the temporary layer.",
  "p_36": "It is important to destroy all created layers, contexts, & buffers before the program terminated. Failure to do so may cause memory leaks that will lead to the plug-in behaving in an unpredictable manner.",
  "p_37": "With the OpenGL context working and rendering in After Effects, I began to add parameters to the plug-in for greater flexibility. The following are the parameters and their use:",
  "l_38": "Segments: number of points to draw.",
  "l_39": "Length: number of points per consecutive line.",
  "l_40": "Range: distance consecutive points of the same line can be from each other.",
  "l_41": "Straightness: length in degrees each angle of a line can make.",
  "l_42": "Drawing Mode: renders points, lines, or fills.",
  "l_43": "Line Color: color of the output.",
  "l_44": "Color Detector: input color.",
  "l_45": "Detector Range: range of acceptable input color.",
  "l_46": "Spread: [debug-feature] how far apart lines would be.",
  "l_47": "Grid Selection: [debug-feature] selecting points in grid manner rather than at random.",
  "l_48": "Gap Selection: allowing lines to cross over gaps.",
  "l_49": "Random Seed: random seed.",
  "l_50": "Subject Layer: layer to apply the effect on.",
  "s_51": "Plug-in Modification & Refinement.",
  "p_52": "I began to test the plug-in on a variety of different footage to see how well it could respond.",
  "i_53": "sketcher/clover-ed-comparisons.gif",
  "d_54": "[Top Left: Original] • [Bottom Left: Edge Detection] • [Top Right: Sketcher] • [Bottom Right: Sketcher + Edge Detection]",
  "p_55": "A problem I was noticing was that the dynamic array I was using to store the pixel locations of pixels that satisfied the color input in the original image was reaching a limit. In some frames, the sketcher app does not cover the entire frame when searching for and drawing over pixels. This is because there are too many pixels in the frame that satisfy the color input, that the sketcher app has to stop searching for, resulting in the bottom half of the frame being empty. This problem is overcome when using the edge detection filter first, as it results in significantly less pixels that satisfy the color input.",
  "p_56": "Getting back to the problem of lines drawing over empty spaces, I added an additional helper function that checked whether the midpoint of the line being drawn was over a pixel that was in range of the color input. This heavily boosted clarity in the image quality.",
  "i_57": "sketcher/clover-ed-gap-comparisons.png",
  "d_58": "[Left: Standard] • [Right: Gap-Detection Helper Function]",
  "p_59": "I added in the additional ability to render the data through points & polygons rather than just through lines. Since the data was all the same, it was a matter of telling OpenGL to render the data fed into it as points or polygons.",
  "i_60": "sketcher/clover-ed-rendering-comparisons.png",
  "d_61": "[Left: Points] • [Middle: Lines] • [Right: Polygons]",
  "p_62": "Despite the points being barely visible, OpenGL does not allow for point/line thickness. They recommend drawing polygons in place of lines and points to increase thickness from the default.",
  "p_63": "Different rendering shapes can be applied over each other, such as combining lines with polygons. This can be done by duplicating a layer with the sketcher effect, and using a linear color key to key out the black background on the upper layer so that its results project onto the lower layer. Then, modify the Drawing Mode parameter to Lines for one and Polygons for the other.",
  "i_64": "sketcher/clover-ed-lines-polygon.gif",
  "d_65": "Combining lines & polygon Drawing Modes.",
  "p_66": "The same can be done with the stroke and fill of an object of simple colors. Using the Build Our McQueen animation cycle, for its distinguishable fill and stroke, I keyed the stroke for one layer, and the fill for another, before applying sketcher effects onto each with different drawing colors.",
  "i_67": "sketcher/cars.gif",
  "d_68": "2 separate sketcher effects applied to edge detected stroke and isolated fill components.",
  "p_69": "The above car animation cycle was what I used during the entire process to test the effect."

}
